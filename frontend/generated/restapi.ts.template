// WARNING: generated file

// tslint:disable
// WHY: wouldn't make sense complicating code generation to check
// if we need template string or not in path string

import {
	AuditlogEntry,
	ExposedSecret,
	FolderResponse,
	SecretKeylistKey,
	WrappedAccount,
	GetSecretsInput,
	U2FEnrollmentChallenge,
	U2FEnrolledToken,
} from 'generated/apitypes';
import {getJson, postJson} from 'httputil';
import {unsealRoute} from 'routes';

{{range .ApplicationTypes.Endpoints}}
// {{.Path}}
export function {{.Name}}({{.TypescriptArgs}}): Promise<{{.Produces.AsTypeScriptType}}> { {{if .Consumes}}
	return postJson<{{.Consumes.AsTypeScriptType}}, {{.Produces.AsTypeScriptType}}>(`{{.TypescriptPath}}`, body);
{{else}}
	return getJson<{{.Produces.AsTypeScriptType}}>(`{{.TypescriptPath}}`);
{{end}} }
{{end}}

export function defaultErrorHandler(err: Error | StructuredErrorResponse) {
	const ser = coerceToStructuredErrorResponse(err);

	if (handleDatabaseSealed(ser)) {
		return;
	}

	alert(`${ser.error_code}: ${ser.error_description}`);
}

export function isSealedError(err: StructuredErrorResponse): boolean {
	return err.error_code === 'database_is_sealed';
}

export function handleDatabaseSealed(err: StructuredErrorResponse): boolean {
	if (isSealedError(err)) {
		document.location.assign(unsealRoute.buildUrl({ redirect: document.location.hash }));
		return true;
	}

	return false;
}

export function coerceToStructuredErrorResponse(err: Error | StructuredErrorResponse): StructuredErrorResponse {
	if (isStructuredErrorResponse(err)) {
		return err;
	}

	return { error_code: 'generic_error', error_description: err.toString() };
}

export interface StructuredErrorResponse {
	error_code: string;
	error_description: string;
}

export function isStructuredErrorResponse(err: StructuredErrorResponse | {}): err is StructuredErrorResponse {
	return 'error_code' in (err as StructuredErrorResponse);
}

