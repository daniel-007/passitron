package apitypes

import (
	"net/http"
	"encoding/json"
	"github.com/function61/pi-security-module/pkg/auth"
)

type Handlers interface { {{range .ApplicationTypes.Endpoints}}
	{{UppercaseFirst .Name}}({{if .Consumes}}input {{.Consumes.AsGoType}}, {{end}}w http.ResponseWriter, r *http.Request){{if .Produces}} *{{.Produces.AsGoType}}{{end}}{{end}}
}

type RequestContext struct {
	User *auth.UserDetails
}

// if returns nul, request handling is aborted.
// in return=nil case middleware is responsible for error response.
type MiddlewareChain func(w http.ResponseWriter, r *http.Request) *RequestContext

type MiddlewareChainMap map[string]MiddlewareChain

// the following generated code brings type safety from all the way to the
// backend-frontend path (input/output structs and endpoint URLs) to the REST API
// TODO: middlewares like auth
func RegisterRoutes(handlers Handlers, mwares MiddlewareChainMap, register func(method string, path string, fn http.HandlerFunc)) { {{range .ApplicationTypes.Endpoints}}
	register("{{.HttpMethod}}", "{{StripQueryFromUrl .Path}}", func(w http.ResponseWriter, r *http.Request) {
		if mwares["{{.MiddlewareChain}}"](w, r) == nil {
			return // middleware aborted request handing and handled error response itself
		}
{{if .Consumes}}		input := &{{.Consumes.AsGoType}}{}
		if ok := parseJsonInput(w, r, input); !ok {
			return // parseJsonInput handled error message
		} {{end}}
{{if .Produces}}
		if out := handlers.{{UppercaseFirst .Name}}({{if .Consumes}}*input, {{end}}w, r); out != nil { handleJsonOutput(w, out) } {{else}}
		handlers.{{UppercaseFirst .Name}}({{if .Consumes}}*input, {{end}}w, r) {{end}}
	})
{{end}}
}

func handleJsonOutput(w http.ResponseWriter, output interface{}) {
	w.Header().Set("Content-Type", "application/json")

	if err := json.NewEncoder(w).Encode(output); err != nil {
		panic(err)
	}
}

func parseJsonInput(w http.ResponseWriter, r *http.Request, input interface{}) bool {
	decoder := json.NewDecoder(r.Body)
	decoder.DisallowUnknownFields()

	if r.Header.Get("Content-Type") != "application/json" {
		http.Error(w, "expecting Content-Type with application/json header", http.StatusBadRequest)
		return false
	}

	if err := decoder.Decode(input); err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return false
	}

	return true
}
